一、实现思路
这个题目与以往的TDD练习题目不一样，不好直接抽象出模型出来，经过几次失败的TDD过程后，静下心来先根据题目建立了数学模型，明确好了再进行的TDD实践。

这个题目可以看做是Fibonacci数列的变种
n>25 f(n) = f(n-25)+f(n-10)+f(n-5)+f(n-1) 
n>10 f(n) = f(n-10)+f(n-5)+f(n-1) 
n>5  f(n) = f(n-5)+f(n-1) 
n=1  1

另外这个题目计算的是组合的个数，而不是排列的个数，比如：6美分兑换为5美分+1美分 和 1美分+5美分 只算一种兑换方式。在计算时，要把重复的去掉。

在实现时，设定了如下规则：每种组合方式第一个硬币都是面值最高的，该组合方式中后边的硬币面值都不能高于第一个硬币。

比如
5美分有两种组合方式:5+1 ;1+1+1+1+1+1

6美分计算时：
（1）第一个硬币先选5美分；第二个硬币只能是1美分；算一种兑换方式
（2）第一个硬币先选1美分；剩下的有5美分有两种组合方式：5+1 1+1+1+1+1+1，5+1不符合“后边的硬币面值都不能高于第一个硬币”的规则，跳过；只能使用1+1+1+1+1+1，算一种兑换方式。
综合算起来只有2种方式。

结合上边的实例，f(n)可变换为
f(6,6) = f(6-5,5) + f(6-1,1) 其中第二个参数是除了第一个硬币外，后边硬币所能使用的最大面值。

二、总结分析

实现过程中参照简单设计的原则进行了重构，消除了重复、函数和变量名字基本表达意图。

不足之处：
1. TDD的步子没有控制，深一脚浅一脚，重构的步子有点大。
2. 为了揭示意图，函数和变量名太长，比如countWaysWhenSetCeiling()这个方法，需要再好好斟酌下。
3. 测试代码中有重复，需要抽离出方法。


根据目前算法，计算得到1美元（100美分）的兑换方式有242种。
